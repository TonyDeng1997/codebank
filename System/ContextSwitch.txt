Context switch

What?
As its name indicates, it is a 'switch', it can be used for
thread switch (switching between two threads within a given process), 
process switch (switching between two processes), mode switch (domain crossing: switching between user mode and kernel mode within a given thread), 
register switch, a stack frame switch, and address space switch (memory map switch: changing virtual memory to physical memory map). 
It is often used for process switch and thread switch which is the is an essential feature of a multitasking operating system.

Cost?
The computational cost of context switches varies significantly depending on what precisely it entails, from little more than a subroutine call for 
light-weight user processes, to very expensive, though typically much less than that of saving or restoring a process image.

Context switches are usually computationally intensive, and much of the design of operating systems is to optimize the use of context switches. 
Switching from one process to another requires a certain amount of time for doing the administration ï¿½C saving and loading registers and memory maps, 
updating various tables and lists, etc. What is actually involved in a context switch varies between these senses and between processors and operating systems. 
For example, in the Linux kernel, context switching involves switching registers, stack pointer, and program counter, but is independent of address space switching, 
though in a process switch an address space switch also happens.[2][3] Further still, analogous context switching happens between user threads, notably green threads, 
and is often very light-weight, saving and restoring minimal context. In extreme cases, such as switching between goroutines in Go, a context switch is equivalent to a coroutine yield, 
which is only marginally more expensive than a subroutine call.

When?

Multitasking

Most commonly, within some scheduling scheme, one process must be switched out of the CPU so another process can run. This context switch can be triggered by the process 
making itself unrunnable, such as by waiting for an I/O or synchronization operation to complete. On a pre-emptive multitasking system, the scheduler may also switch out 
processes which are still runnable. To prevent other processes from being starved of CPU time, preemptive schedulers often configure a timer interrupt to fire when a process 
exceeds its time slice. This interrupt ensures that the scheduler will gain control to perform a context switch.

Interrupt handling

Modern architectures are interrupt driven. This means that if the CPU requests data from a disk, for example, it does not need to busy-wait until the read is over; 
it can issue the request and continue with some other execution. When the read is over, the CPU can be interrupted and presented with the read. For interrupts, 
a program called an interrupt handler is installed, and it is the interrupt handler that handles the interrupt from the disk.

When an interrupt occurs, the hardware automatically switches a part of the context (at least enough to allow the handler to return to the interrupted code). 
The handler may save additional context, depending on details of the particular hardware and software designs. Often only a minimal part of the context is changed 
in order to minimize the amount of time spent handling the interrupt. The kernel does not spawn or schedule a special process to handle interrupts, but instead the 
handler executes in the (often partial) context established at the beginning of interrupt handling. Once interrupt servicing is complete, the context in effect before 
the interrupt occurred is restored so that the interrupted process can resume execution in its proper state.

User and kernel mode switching

When a transition between user mode and kernel mode is required in an operating system, a context switch is not necessary; 
a mode transition is not by itself a context switch. However, depending on the operating system, a context switch may also take place at this time.
